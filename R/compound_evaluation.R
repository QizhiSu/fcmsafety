#' Export input file for toxtree batch processing
#'
#' After \code{extract_cid()} and \code{extract_meta()} for your data, you can
#' use this function to export a *.csv file that can be used by the Toxtree
#' software for batch processing.
#'
#' @param data Your data after the \code{extract_cid()} and \code{extract_meta()}
#' steps
#' @param cas_col The index of column that contains CAS information. CAS number
#' is not mandatory for each compound, if no CAS is available, then chemical name
#' will be used for retreival. However, a column index is still required.
#' @param name_col The index of column that contains chemical name.
#' @param output The output file name end with .csv. The default value is
#' "for_toxtree.csv"
#'
#' @return No return but a *.csv file for Toxtree.
#'
#' @import dplyr
#' @importFrom rio export
#'
#' @export
export4toxtree <-
  function(data, cas_col,
           name_col,
           output = "for_toxtree.csv") {
  data <- data %>%
    mutate(NAME = .[, name_col],
           CAS = .[, cas_col],
           SMILES = SMILES) %>%
    select(NAME, CAS, SMILES) %>%
    filter(!is.na(SMILES))

  rio::export(data, output)
}


#' Evaluate toxicity, get flavornet and classyfire information
#'
#' @param data Your data after the \code{extract_cid()} and \code{extract_meta()}
#'
#' @param toxtree_result The *.csv file generated by Toxtree batch processing.
#' The defalut value is "toxtree_results.csv", which means the output files in
#' Toxtree batching processing is "toxtree_results.csv". If other output name is
#' used in Toxtree, please use the corresponding name here.
#' @param flavornet A logical value for flavornet information retrieval.
#' @param cas_col In case you want to retrieve flavornet information, please
#' specify the index of column that contains CAS number which can be retrieved
#' using \code{extract_meta()} function.
#' @param classyfire A logical value for classyfire information retrieval.
#'
#' @return A data.frame or tibble with toxicity assigned.
#'
#' @import dplyr
#' @import webchem
#' @import classyfireR
#' @import purrr
#' @importFrom utils read.csv
#'
#' @export
evaluate_compound <-
  function(data,
           toxtree_result = "toxtree_results.csv",
           flavornet = TRUE,
           cas_col = NA,
           classyfire = TRUE
           ) {
  # read in toxtree result
  tox <- read.csv(toxtree_result)

  data <- data %>%
    mutate(
      Cramer_rules = tox$Cramer.rules[match(SMILES, tox$SMILES)],
      # to check if the compounds present in any of the database
      SVHC = case_when(InChIKey %in% svhc_meta$InChIKey ~ "Y"),
      CMR = case_when(InChIKey %in% cmr_meta$InChIKey ~ "Y"),
      CMR_suspect = case_when(InChIKey %in% cmr_suspect_meta$InChIKey ~ "Y"),
      EDC = case_when(InChIKey %in% edc_meta$InChIKey ~ "Y"),
      IARC = iarc_meta$Group[match(InChIKey, iarc_meta$InChIKey)] %>% na_if("3"),
      EU_SML = eu_sml_meta$SML[match(InChIKey, eu_sml_meta$InChIKey)],
      EU_SML_group = eu_sml_meta$SML_group[match(InChIKey, eu_sml_meta$InChIKey)],
      # it is possible to have both SML and SML_group
      # in this case, use only SML
      EU_SML = case_when(
        is.na(EU_SML) & !is.na(EU_SML_group)
        ~ eu_sml_group$SML[match(EU_SML_group, eu_sml_group$`Group Restriction No`)],
        TRUE ~ EU_SML),
      China_SML = china_sml_meta$SML[match(InChIKey, china_sml_meta$InChIKey)],
      China_SML_group = china_sml_meta$SML_group[match(InChIKey, china_sml_meta$InChIKey)],
      China_SML = case_when(is.na(China_SML & ! is.na(China_SML_group)) ~ China_SML_group,
                            TRUE ~ China_SML),

      Cramer_rules = case_when(
        !is.na(SVHC) | !is.na(CMR) | !is.na(CMR_suspect) | !is.na(EDC)
        | !is.na(IARC) | !is.na(EU_SML) | !is.na(China_SML) ~ "-",
        TRUE ~ Cramer_rules
      ),

      # assign toxiticy
      Toxic_level = case_when(
        !is.na(SVHC) | !is.na(CMR) | !is.na(EDC) | IARC == "1" |
          EU_SML <= 0.018 | China_SML <= 0.018 ~ "V",

        !is.na(CMR_suspect) | IARC == "2A" | IARC == "2B"
        | Cramer_rules == "High (Class III)" |
          (EU_SML > 0.018 & EU_SML <= 0.09) | (China_SML > 0.018 & China_SML <= 0.09) ~ "IV",

        Cramer_rules == "Intermediate (Class II)" |
          (EU_SML > 0.09 & EU_SML <= 0.54) | (China_SML > 0.09 & China_SML <= 0.54) ~ "III",

        Cramer_rules == "Low (Class I)" |
          (EU_SML > 0.54 & EU_SML <= 1.8) | (China_SML > 0.54 & China_SML <= 1.8) ~ "II",

        (EU_SML > 1.8 & EU_SML <= 60) | (China_SML > 1.8 & China_SML <= 60) ~ "I"
      ),

      # mark group SML
      EU_SML = case_when(!is.na(EU_SML_group) ~ paste0(EU_SML, "*"),
                         TRUE ~ as.character(EU_SML)),
      China_SML = case_when(!is.na(China_SML_group) ~ paste0(China_SML, "*"),
                            TRUE ~ as.character(China_SML)),
      EU_SML_group = NULL,
      China_SML_group = NULL
    )

  if(flavornet == TRUE) {
    data$Flavornet = webchem::fn_percept(data[, cas_col])
    }

  if(classyfire == TRUE) {
    # extract classification from classyfireR
    classyfire <- data$InChIKey %>%
      unique() %>% # remove duplicates
      purrr::map(classyfireR::get_classification) %>%
      purrr::discard(is.null)
    # extract meta data for classification
    classyfire_meta <- classyfire %>%
      purrr::map(classyfireR::meta)%>%
      sapply("[[", 1) %>%
      str_remove("InChIKey=") %>%
      as_tibble() %>%
      rename(InChIKey = value)

    data <-
      classyfire %>%
      purrr::map(classyfireR::classification) %>%
      lapply(extract_cla) %>%
      do.call("bind_rows", .) %>% # collapse the list into a data.frame
      cbind(classyfire_meta, .) %>% # join with InChIKey
      left_join(data, ., by = "InChIKey") # join with the raw table
  }

  # replace NA with "-
  data[is.na(data)] <- "-"

  return(data)
}
